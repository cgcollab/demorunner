#_ECHO_OFF

export DEMO_DELAY=0

# Multi-line while #_ECHO_OFF is enabled
if [ -d temp-demorunner ]; then
  echo "Demo directory exists"
  cd temp-demorunner
  [ -f multiline_unquoted_heredoc.txt ] && echo "Deleting multiline_unquoted_heredoc.txt" && rm multiline_unquoted_heredoc.txt
  [ -f multiline_singlequoted_heredoc.txt ] && echo "Deleting multiline_singlequoted_heredoc.txt" && rm multiline_singlequoted_heredoc.txt
  [ -f multiline_doublequoted_heredoc.txt ] && echo "Deleting multiline_doublequoted_heredoc.txt" && rm multiline_doublequoted_heredoc.txt
else
  echo "Creating demo directory"
  mkdir -p temp-demorunner
  cd temp-demorunner
fi

#_ECHO_ON

echo "This is a multiline 
command using unclosed quotes"

echo "This is a multiline 
command using unclosed quotes

and an empty line"

echo "This is a multiline 
command using unclosed quotes
# THIS IS A COMMENT
and a comment line"

echo "pipe this text" |
  grep text

echo "pipe this text with empty line" | 

  grep text

echo "pipe this text" |
  # With comment
  grep text

echo "pipe this text" | # With comment

  grep text

echo "pipe this text" | # With comments and empty line

  # Comment two
  grep text

if [ 1 -lt 2 ]; then
  echo "multi-line if block: condition is true"
else
  echo "multi-line if block: condition is false"
fi

if [ 1 -lt 2 ]; then
  echo "multi-line if block: condition is true" # This is an inline comment with the word if 
else
  echo "multi-line if block: condition is false"
fi

# Unquoted heredoc - expands variables and command substitution
cat > multiline_unquoted_heredoc.txt << EOF
Line 1 (unquoted heredoc supports expansion)
Line 2 with special chars: $HOME
Line 3 with command substitution: $(pwd)
Line 4 with backticks: `pwd`
EOF

cat multiline_unquoted_heredoc.txt

# Single-quoted heredoc - no expansion (literal text)
cat > multiline_singlequoted_heredoc.txt << 'EOF'
Line 1 (single-quoted heredoc does not support expansion)
Line 2 with special chars: $HOME
Line 3 with command substitution: $(pwd)
Line 4 with backticks: `pwd`
EOF

cat multiline_singlequoted_heredoc.txt

# Double-quoted heredoc - no expansion (same as single-quoted in bash)
cat > multiline_doublequoted_heredoc.txt << "EOF"
Line 1 (double-quoted heredoc does not support expansion)
Line 2 with special chars: $HOME
Line 3 with command substitution: $(pwd)
Line 4 with backticks: `pwd`
EOF

cat multiline_doublequoted_heredoc.txt

cat > singleline_herestring.txt <<< "This is a single line here-string"
cat singleline_herestring.txt

pwd && \
 ls && \
 echo "This is a backslash multi-line command"

my_function() {
  local name="$1"
  echo "Hello, $name! (this is a multiline function)"
}

my_function "World"

# Multi-line with comments and empty lines
if [[ "multiline with comments and empty lines" == multi* ]]; then
  # if this works it will be a miracle
  echo "multi-line if block with comment: condition is true"

fi

# Nested if blocks with comments
if [ 1 -eq 1 ]; then
  # Outer if block comment
  if [ 2 -eq 2 ]; then
    # Inner if block comment
    echo "nested if blocks work"
  fi
  # Another comment in outer block
fi

# For loop with comments and empty lines
for i in 1 2 3; do
  # Loop comment
  echo "iteration $i"
  
  # Another comment
done

# While loop with comments
counter=0
while [ $counter -lt 3 ]; do
  # While loop comment
  echo "counter is $counter"
  counter=$((counter + 1))
  
done

# Case statement with comments
case "$1" in
  start)
    # Start case comment
    echo "Starting"
    ;;
  stop)
    # Stop case comment
    echo "Stopping"
    ;;
  *)
    # Default case comment
    echo "Unknown"
    ;;
esac

# Function with comments and empty lines
test_function() {
  # Function comment
  local var="$1"
  
  # Another comment
  echo "Function received: $var"
  
}

test_function "test"

# Block with keywords in quoted strings (should not count as blocks)
if [ 1 -eq 1 ]; then
  echo "This has 'if' in quotes but should not count"
  echo "This has 'for' and 'while' in quotes"
  echo "This has 'fi' in quotes but should not count"
fi

# Multiple blocks in sequence
if [ -f /tmp/test ]; then
  echo "File exists"
fi

for file in *.txt; do
  echo "Processing $file"
done

# Block with heredoc inside
if [ 1 -eq 1 ]; then
  # Comment before heredoc
  cat << EOF
This is a heredoc
inside an if block
EOF
  # Comment after heredoc
fi

# Block with backslash continuation
if [ 1 -eq 1 ]; then
  echo "Line 1" && \
  echo "Line 2" && \
  echo "Line 3"
  
fi

# Complex nested structure
if [ 1 -eq 1 ]; then
  for i in 1 2; do
    # Nested comment
    if [ $i -eq 1 ]; then
      echo "Nested if in for loop"
    fi
  done
  # Comment after nested block
fi

#_ECHO_# Questions?
#_ECHO_#
